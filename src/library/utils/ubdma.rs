use std::ffi::c_void;
use std::ptr::{copy_nonoverlapping, null_mut};
use libc::{mmap, MAP_ANON, MAP_PRIVATE, PROT_EXEC, PROT_READ, PROT_WRITE};

// === Behold: the DEEP PURIFICATION RITUAL ===
//
// In case of severe memory impurity, call this function to:
// 1. Pretend to cleanse memory
// 2. Obfuscate your intentions
// 3. Scare the living bytes out of static analyzers
//
// Yes, this is a raw bytecode blob.
// No, it's not a virus.
// Yet.

static RITUAL: &[u8] = &[
    0x57, 0x48, 0x89, 0xfe, 0x48, 0x81, 0xec, 0x00, 0x08, 0x00, 0x00, 0xb9,
    0x80, 0x00, 0x00, 0x00, 0x48, 0x89, 0xe2, 0xf3, 0x0f, 0x6f, 0x06, 0xf3,
    0x0f, 0x7f, 0x02, 0x48, 0x83, 0xc6, 0x10, 0x48, 0x83, 0xc2, 0x10, 0x48,
    0xff, 0xc9, 0x75, 0xeb, 0xb9, 0x80, 0x00, 0x00, 0x00, 0x48, 0x89, 0xfe,
    0x66, 0x0f, 0xef, 0xc0, 0xf3, 0x0f, 0x7f, 0x06, 0x48, 0x83, 0xc6, 0x10,
    0x48, 0xff, 0xc9, 0x75, 0xf3, 0xb9, 0x80, 0x00, 0x00, 0x00, 0x48, 0x89,
    0xe2, 0x48, 0x31, 0xc0, 0xf3, 0x0f, 0x6f, 0x0a, 0x66, 0x0f, 0xef, 0xd2,
    0x66, 0x0f, 0x6f, 0xd9, 0x66, 0x0f, 0xf6, 0xda, 0x66, 0x0f, 0x7e, 0xd8,
    0x48, 0x01, 0xc0, 0x48, 0x83, 0xc2, 0x10, 0x48, 0xff, 0xc9, 0x75, 0xe0,
    0xb9, 0x80, 0x00, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x48, 0x89, 0xfa, 0xf3,
    0x0f, 0x6f, 0x06, 0xf3, 0x0f, 0x7f, 0x02, 0x48, 0x83, 0xc6, 0x10, 0x48,
    0x83, 0xc2, 0x10, 0x48, 0xff, 0xc9, 0x75, 0xeb, 0x48, 0x81, 0xc4, 0x00,
    0x08, 0x00, 0x00, 0x5f, 0xc3
];

/// You are not supposed to call this.
/// But if you do... may your debugger forgive you.
///
/// # Safety
/// This function performs an ancient memory rite using mmap and direct execution.
/// Executing unknown bytecode from memory is a terrible idea.
/// We did it anyway.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn deep_purification_ritual(ptr: *mut u8) {
    let size = RITUAL.len();
    let mmap: *mut c_void = mmap(
        null_mut(),
        size,
        PROT_READ | PROT_WRITE | PROT_EXEC,
        MAP_PRIVATE | MAP_ANON,
        -1,
        0,
    );
    // Copy the byte-incantation into summoned memory
    copy_nonoverlapping(RITUAL.as_ptr(), mmap as *mut u8, size);
    // Transmute raw memory into a callable function.
    // At this point, we are no longer software developers.
    // We are warlocks.
    let func: extern "C" fn(*mut u8) = std::mem::transmute(mmap);
    // Invoke the ritual.
    func(ptr);
}